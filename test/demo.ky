import stl;

// neither i or j are deffined
demo_scope() -> void
{
	// neither i or j are deffined
	i := 0;
	// i is deffined, j is not
	{
		j := 0;
		// i and j are deffined
	}
	// i is deffined, j is not
}
// neither i or j are deffined

demo_type_capture(collection : CAPTURED_TYPE_2D_ARRAY<CAPTURED_TYPE_ELEMENT<any>[A][B]>) -> void
{
	A and B are the dimentions 
	new_collection : CAPTURED_TYPE_2D_ARRAY;
}

demo_local_functions() -> int
{
	collection := {1, 2, 3, 4, 5};
	total := 0;

	iterate(collection, (item : int) -> void
	{
		total += item;
	});

	return total;
}

demo_inline_spir() -> void
{
	spir("
		OpCapability Shader
		OpMemoryModel Logical Simple
		OpEntryPoint GLCompute %3 "main"
		OpExecutionMode %3 LocalSize 64 64 1
	%1 = OpTypeVoid
	%2 = OpTypeFunction %1
	%3 = OpFunction %1 None %2
	%4 = OpLabel
		OpReturn
		OpFunctionEnd
	");
}

demo_structs() -> void
{
	new_type := struct
	{
		member : int;
	};
}

demo_nested_comments() -> void
{
	/*
		/*
			comment
		*/
	*/
}

demo_multiple_named_returns() -> a : int, b : double
{
	return 0, 0.0;
}

demo_multiple_named_returns_pt2() -> void
{
	ret := demo_multiple_named_returns();
	ret.a;
	ret.b;
	{a, b} := ret; // struct decomposition

	{a, b} := demo_multiple_named_returns();

	a : int;
	b : double;
	{a, b} = demo_multiple_named_returns();

	{0, 0.0}; // implicit struct
	{a, b} := {0, 0.0};

	typeof({0, 0.0}); // returns "{int, double}"
	T<{0, 0.0}>;
}
