// Kyte Standard Library
// Types
// Predefined
const VOID_FUNCTION := (() -> void);

// Mat
const mat2b := bool[2][2];
const mat3b := bool[3][3];
const mat4b := bool[4][4];
const mat2i := int[2][2];
const mat3i := int[3][3];
const mat4i := int[4][4];
const mat2u := uint[2][2];
const mat3u := uint[3][3];
const mat4u := uint[4][4];
const mat2f := float[2][2];
const mat3f := float[3][3];
const mat4f := float[4][4];
const mat2d := double[2][2];
const mat3d := double[3][3];
const mat4d := double[4][4];

const mat2 := <mat2b, mat2i, mat2u, mat2f, mat2d>;
const mat3 := <mat3b, mat3i, mat3u, mat3f, mat3d>;
const mat4 := <mat4b, mat4i, mat4u, mat4f, mat4d>;

const matb := <mat2b, mat3b, mat4b>;
const mati := <mat2i, mat3i, mat4i>;
const matu := <mat2u, mat3u, mat4u>;
const matf := <mat2f, mat3f, mat4f>;
const matd := <mat2d, mat3d, mat4d>;

const matn := <mat2, mat3, mat4>;

// Vec
const vec2b := bool[2];
const vec3b := bool[3];
const vec4b := bool[4];
const vec2i := int[2];
const vec3i := int[3];
const vec4i := int[4];
const vec2u := uint[2];
const vec3u := uint[3];
const vec4u := uint[4];
const vec2f := float[2];
const vec3f := float[3];
const vec4f := float[4];
const vec2d := double[2];
const vec3d := double[3];
const vec4d := double[4];

const vec2 := <vec2b, vec2i, vec2u, vec2f, vec2d>;
const vec3 := <vec3b, vec3i, vec3u, vec3f, vec3d>;
const vec4 := <vec4b, vec4i, vec4u, vec4f, vec4d>;

const vecb := <vec2b, vec3b, vec4b>;
const veci := <vec2i, vec3i, vec4i>;
const vecu := <vec2u, vec3u, vec4u>;
const vecf := <vec2f, vec3f, vec4f>;
const vecd := <vec2d, vec3d, vec4d>;

const vecn := <vec2, vec3, vec4>;

// Scalar
const whole := <int, uint>;
const fractional := <float, double>;
const numeric := <whole, fractional>;
const scalar := <bool, numeric>;

// Sampler
const sampler := <sampler2D, sampler3D>;

// Operators
extern operator+(a : T<vecn>, b : T) -> T;
extern operator-(a : T<vecn>, b : T) -> T;
extern operator*(a : T<vecn>, b : T) -> T;
extern operator/(a : T<vecn>, b : T) -> T;

extern operator+(a : T<matn>, b : T) -> T;
extern operator-(a : T<matn>, b : T) -> T;
extern operator*(a : T<matn>, b : T) -> T;
extern operator/(a : T<matn>, b : T) -> T;

// Functions
// Angle
extern radians(degrees : T<numeric, vecn>) -> T;
extern degrees(radians : T<numeric, vecn>) -> T;

// Trigonometry
extern sin(angle : T<numeric, vecn>) -> T;
extern cos(angle : T<numeric, vecn>) -> T;
extern tan(angle : T<numeric, vecn>) -> T;
extern asin(x : T<numeric, vecn>) -> T;
extern acos(x : T<numeric, vecn>) -> T;
extern atan(y : T<numeric, vecn>, x : T) -> T;
extern atan(y_over_x : T<numeric, vecn>) -> T;
extern sinh(x : T<numeric, vecn>) -> T;
extern cosh(x : T<numeric, vecn>) -> T;
extern tanh(x : T<numeric, vecn>) -> T;
extern asinh(x : T<numeric, vecn>) -> T;
extern acosh(x : T<numeric, vecn>) -> T;
extern atanh(x : T<numeric, vecn>) -> T;

// Exponential
extern pow(base : T<numeric, vecn>, exponent : T) -> T;
extern exp(exponent : T<numeric, vecn>) -> T;
extern log(float) -> float;
extern ln(float) -> float;
extern exp2(float) -> float;
extern log2(float) -> float;
extern sqrt(float) -> float;

// Arithmetic
extern abs(x : T<numeric>) -> T;
extern floor(float) -> int;
extern ceil(float) -> int;
extern fract(float) -> float;
extern mod(float, float) -> float;
extern min(float, float) -> float;
extern max(float, float) -> float;
extern clamp(low : T<numeric>, high : T, x : T) -> float;
extern mix(float, float, float) -> float;
extern step(float, float) -> float;
extern smoothstep(float, float, float) -> float;

// Vector
extern length(vector : vec) -> float;
extern distance(float, float) -> float;
extern dot(float, float) -> float;
extern cross(float, float) -> vec3;
extern normalize(vector : T<vec>) -> T;
extern faceforward(vec, vec, vec) -> vec;
extern reflect(vec, vec) -> vec;
extern refract(vec, vec, float) -> vec;

// Matrix


// Texture
extern sample(sampler2D, vec2f) -> vec4f;
extern sample(sampler3D, vec3f) -> vec4f;

// Misc
cast(value : any, T : type) -> T
{
	return (T)value;
}

typeof(var : T<any>) -> type
{
	return T;
}

iterate(collection : T<any>[], iterator_function : ((T) -> void)) -> void
{
	for (i := 0; i < collection.size; i++)
	{
		iterator_function(collection[i]);
	}
}
// iterate : (T<any>[][], (T) -> void) -> void;
iterate := (collection : T<any>[X][Y], iterator_function : (T) -> void) -> void
{
	for (i := 0; i < X; i++)
	{
		for (j := 0; j < Y; j++)
		{
			iterator_function(collection[i][j]);
		}
	}
}
